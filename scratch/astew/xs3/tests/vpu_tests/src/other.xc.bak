
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>

#include "xs3_vpu.h"
#include "xs3_fpu.h"


void test_vladd();

#ifdef __XC__
#define WORD_ALIGNED [[aligned(4)]]
#else
#define WORD_ALIGNED
#endif

#define EACH_INT8(ITER)  size_t ITER = 0; ITER <   XS3_VPU_VREG_WIDTH_BYTES; ITER++
#define EACH_INT16(ITER) size_t ITER = 0; ITER < 2*XS3_VPU_VREG_WIDTH_WORDS; ITER++
#define EACH_INT32(ITER) size_t ITER = 0; ITER <   XS3_VPU_VREG_WIDTH_WORDS; ITER++

static void status_stuff()
{
    vsetc_simple(VEC_INT_32, VEC_SH0, 0);

    unsigned mode, shift, headroom;
    vgetc_simple(&mode, &shift, &headroom);
    
    assert(mode == VEC_INT_32);
    assert(shift == VEC_SH0);
    assert(headroom == 0);
    
    vsetc_simple(VEC_INT_8, VEC_SHL, 4);
    vgetc_simple(&mode, &shift, &headroom);

    assert(mode == VEC_INT_8);
    assert(shift == VEC_SHL);
    assert(headroom == 4);
}

static void load_store()
{
    char WORD_ALIGNED buffer1[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    char WORD_ALIGNED buffer2[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    char WORD_ALIGNED buffer3[XS3_VPU_VREG_WIDTH_BYTES] = {0};

    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++) {
        buffer1[i] = i;
        buffer2[i] = i + 32;
        buffer3[i] = i + 64;
    }

    vldr(buffer1);
    vldc(buffer2);
    vldd(buffer3);

    memset(buffer1, 0, sizeof(buffer1));
    memset(buffer2, 0, sizeof(buffer2));
    memset(buffer3, 0, sizeof(buffer3));

    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++){
        assert(buffer1[i] == 0);
        assert(buffer2[i] == 0);
        assert(buffer3[i] == 0);
    }

    vstr(buffer1);
    vstc(buffer2);
    vstd(buffer3);

    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++){
        assert(buffer1[i] == i);
        assert(buffer2[i] == i + 32);
        assert(buffer3[i] == i + 64);
    }
}

static void load_store_partial()
{
    char WORD_ALIGNED buffer1[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    
    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++) 
        buffer1[i] = i;
    

    vldr(buffer1);

    memset(buffer1, 0, sizeof(buffer1));
    
    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++)
        assert(buffer1[i] == 0);
    
    unsigned mask = 0b01010101010101010101010101010101;
    vstrpv(buffer1, mask);
    
    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++){
        char v = ((i%2) == 0)? i : 0;
        assert(buffer1[i] == v);
    }
    
    memset(buffer1, 0, sizeof(buffer1));
    
    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++)
        assert(buffer1[i] == 0);
    
    // LSb corresponds to memory address!!
    mask = 0b00000000000000001111111111111111;
    vstrpv(buffer1, mask);
    
    for(size_t i = 0; i < XS3_VPU_VREG_WIDTH_BYTES; i++){
        char v = (i < 16)? i : 0;
        assert(buffer1[i] == v);
    }
}

static void add_sub_mul()
{

    vsetc_simple(VEC_INT_8, VEC_SH0, 32);
    vclrdr();
    
    int8_t WORD_ALIGNED data[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    int8_t WORD_ALIGNED vR[XS3_VPU_VREG_WIDTH_BYTES] = {0};

    vldr(vR);

    for(EACH_INT8(i))
        assert(vR[i] == 0);

    for(EACH_INT8(i)) 
        data[i] = i;

    vladd(data);
    vstr(vR);

    for(EACH_INT8(i))
        assert(vR[i] == data[i]);

    vclrdr();

    vlsub(data);
    vstr(vR);

    for(EACH_INT8(i))
        assert(vR[i] == data[i]);

    memcpy(vR, data, sizeof(vR));
    memset(data, 0, sizeof(data));

    vldr(vR);
    vlsub(data);
    memcpy(data, vR, sizeof(vR));
    vstr(vR);

    for(EACH_INT8(i))
        assert(vR[i] == -data[i]);

    for(EACH_INT8(i)){
        // 0b01000000 is unity in int8 mode
        vR[i] = 0b01000000;
        data[i] = i;
    }

    vldr(vR);
    vlmul(data);
    vstr(vR);

    for(EACH_INT8(i))
        assert(vR[i] == i);

    for(EACH_INT8(i)){
        // 0b01100000 is 1.5 in int8 mode
        vR[i] = 0b01100000;
        data[i] = 2*i;
    }

    vldr(vR);
    vlmul(data);
    vstr(vR);

    for(EACH_INT8(i))
        assert(vR[i] == 3*i);


    for(EACH_INT8(i)){
        vR[i] = -128;
        data[i] = -128;
    }

    vldr(vR);
    vlmul(data);
    vstr(vR);

    for(EACH_INT8(i))
        assert(vR[i] == 127);
    
}

static void vdepth()
{
    vsetc_simple(VEC_INT_8, VEC_SH0, 32);
    vclrdr();

    int8_t WORD_ALIGNED vR[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    int16_t* vR16 = (int16_t*) vR;
    int32_t* vR32 = (int32_t*) vR;

    for(EACH_INT8(i)){
        if(i%2) vR[i] = -i;
        else    vR[i] =  i;
    }

    vldr(vR);
    vdepth1();
    vstr(vR);

    for(EACH_INT8(i)){
        // printf("%u\t%d\n", i, vR[i]);
        if(i>3)   assert(vR[i] == 0);
        else      assert(vR[i] == ((int8_t)0xAA));
    }
    
    vsetc_simple(VEC_INT_16, VEC_SH0, 32);
    vclrdr();
    
    for(EACH_INT16(i)){
        if(i%2) vR16[i] = -i * (1<<8);
        else    vR16[i] =  i * (1<<8) + ((1<<7)-1);
    }

    vldr(vR);
    vdepth8();
    vstr(vR);

    for(EACH_INT8(i)){
        // printf("%u\t%d\n", i, vR[i]);
        if(i>=16)       assert(vR[i] ==  0);
        else if(i%2)    assert(vR[i] == -i);
        else            assert(vR[i] ==  i);
    }
    
    for(EACH_INT16(i)){
        if(i%2) vR16[i] = -i * (1<<8);
        else    vR16[i] =  i * (1<<8) + (1<<7);
    }

    vldr(vR);
    vdepth8();
    vstr(vR);

    for(EACH_INT8(i)){
        // printf("%u\t%d\n", i, vR[i]);
        if(i>=16)       assert(vR[i] ==    0);
        else if(i%2)    assert(vR[i] ==   -i);
        else            assert(vR[i] ==  i+1);
    }
    
    vsetc_simple(VEC_INT_32, VEC_SH0, 32);
    vclrdr();
    
    for(EACH_INT32(i)){
        if(i%2) vR32[i] = -i * (1<<16);
        else    vR32[i] =  i * (1<<16) + ((1<<15)-1);
    }

    vldr(vR);
    vdepth16();
    vstr(vR);

    for(EACH_INT16(i)){
        // printf("%u\t%d\n", i, vR16[i]);
        if(i>=8)        assert(vR16[i] ==  0);
        else if(i%2)    assert(vR16[i] == -i);
        else            assert(vR16[i] ==  i);
    }
}

static void headroom_check()
{    
    char WORD_ALIGNED vR[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    char WORD_ALIGNED vD[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    char WORD_ALIGNED vC[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    char WORD_ALIGNED buff[XS3_VPU_VREG_WIDTH_BYTES] = {0};
    
    int16_t* vR16 = (int16_t*) vR; int32_t* vR32 = (int32_t*) vR;
    int32_t* vD32 = (int32_t*) vD;
    int32_t* vC32 = (int32_t*) vC;

    unsigned mode, shift, headroom;
    vsetc_simple(VEC_INT_32, VEC_SH0, 0);
    vgetc_simple(&mode, &shift, &headroom);

    assert(headroom == 0);

    vclrdr();
    
    vstr(buff);
    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 0);
    vstd(buff);
    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 0);
    
    for(EACH_INT32(i)) {
        vR32[i] = (1<<5)-1;
        vC32[i] = (1<<6)-1;
        vD32[i] = (1<<7)-1;
    }

    vldr(vR);
    vldc(vC);
    vldd(vD);

    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 0);

    vstr(buff);

    for(EACH_INT32(i))
        assert( ((int32_t*)buff)[i] == (1<<5)-1);

    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 5);

    vstc(buff);

    for(EACH_INT32(i))
        assert( ((int32_t*)buff)[i] == (1<<6)-1);

    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 6);

    vstd(buff);

    for(EACH_INT32(i))
        assert( ((int32_t*)buff)[i] == (1<<7)-1);

    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 7);
    

    vsetc_simple(VEC_INT_32, VEC_SH0, 0);

    for(EACH_INT32(i)) {
        vR32[i] = 0x3FFFFFFF;
    }

    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 0);
    vldr(vR);
    vstr(buff);

    vgetc_simple(&mode, &shift, &headroom);
    assert(31-headroom == 1);


    vsetc_simple(VEC_INT_16, VEC_SH0, 0);

    for(EACH_INT16(i))
        vR16[i] = 0x0FFF;

    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 0);
    vldr(vR);
    vstr(buff);

    vgetc_simple(&mode, &shift, &headroom);
    assert(15-headroom == 3);


    vsetc_simple(VEC_INT_8, VEC_SH0, 0);

    for(EACH_INT8(i))
        vR[i] = 0x02;

    vgetc_simple(&mode, &shift, &headroom);
    assert(headroom == 0);
    vldr(vR);
    vstr(buff);

    vgetc_simple(&mode, &shift, &headroom);
    assert(7-headroom == 5);
}
